// Generated by `wit-bindgen` 0.18.0. DO NOT EDIT!
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "run"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_run() -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::run();
    let ptr1 = _RET_AREA.0.as_mut_ptr() as i32;
    match result0 {
      Ok(_) => { {
        *((ptr1 + 0) as *mut u8) = (0i32) as u8;
      } },
      Err(e) => { {
        *((ptr1 + 0) as *mut u8) = (1i32) as u8;
        let vec2 = (e.into_bytes()).into_boxed_slice();
        let ptr2 = vec2.as_ptr() as i32;
        let len2 = vec2.len() as i32;
        ::core::mem::forget(vec2);
        *((ptr1 + 8) as *mut i32) = len2;
        *((ptr1 + 4) as *mut i32) = ptr2;
      } },
    };ptr1
  }
  
  const _: () = {
    #[doc(hidden)]
    #[export_name = "cabi_post_run"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_run(arg0: i32,) {
      let l0 = i32::from(*((arg0 + 0) as *const u8));
      match l0 {
        0 => (),
        _ => {
          let l1 = *((arg0 + 4) as *const i32);
          let l2 = *((arg0 + 8) as *const i32);
          wit_bindgen::rt::dealloc(l1, (l2) as usize, 1);
        },
      }
    }
  };
};
use super::Component as _GuestImpl;
pub trait Guest {
  fn run() -> Result<(),wit_bindgen::rt::string::String>;
}

#[allow(unused_imports)]
use wit_bindgen::rt::{alloc, vec::Vec, string::String};

#[repr(align(4))]
struct _RetArea([u8; 12]);
static mut _RET_AREA: _RetArea = _RetArea([0; 12]);
pub mod component {
  pub mod usb {
    
    #[allow(clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum DeviceHandleError {
        Io,
        InvalidParam,
        Access,
        NoDevice,
        NotFound,
        Busy,
        Timeout,
        Overflow,
        Pipe,
        Interrupted,
        NoMem,
        NotSupported,
        BadDescriptor,
        Other,
      }
      impl DeviceHandleError{
        pub fn name(&self) -> &'static str {
          match self {
            DeviceHandleError::Io => "io",
            DeviceHandleError::InvalidParam => "invalid-param",
            DeviceHandleError::Access => "access",
            DeviceHandleError::NoDevice => "no-device",
            DeviceHandleError::NotFound => "not-found",
            DeviceHandleError::Busy => "busy",
            DeviceHandleError::Timeout => "timeout",
            DeviceHandleError::Overflow => "overflow",
            DeviceHandleError::Pipe => "pipe",
            DeviceHandleError::Interrupted => "interrupted",
            DeviceHandleError::NoMem => "no-mem",
            DeviceHandleError::NotSupported => "not-supported",
            DeviceHandleError::BadDescriptor => "bad-descriptor",
            DeviceHandleError::Other => "other",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            DeviceHandleError::Io => "",
            DeviceHandleError::InvalidParam => "",
            DeviceHandleError::Access => "",
            DeviceHandleError::NoDevice => "",
            DeviceHandleError::NotFound => "",
            DeviceHandleError::Busy => "",
            DeviceHandleError::Timeout => "",
            DeviceHandleError::Overflow => "",
            DeviceHandleError::Pipe => "",
            DeviceHandleError::Interrupted => "",
            DeviceHandleError::NoMem => "",
            DeviceHandleError::NotSupported => "",
            DeviceHandleError::BadDescriptor => "",
            DeviceHandleError::Other => "",
          }
        }
      }
      impl ::core::fmt::Debug for DeviceHandleError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeviceHandleError")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for DeviceHandleError{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }
      
      impl std::error::Error for DeviceHandleError{}
      
      impl DeviceHandleError{
        pub(crate) unsafe fn _lift(val: u8) -> DeviceHandleError{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => DeviceHandleError::Io,
            1 => DeviceHandleError::InvalidParam,
            2 => DeviceHandleError::Access,
            3 => DeviceHandleError::NoDevice,
            4 => DeviceHandleError::NotFound,
            5 => DeviceHandleError::Busy,
            6 => DeviceHandleError::Timeout,
            7 => DeviceHandleError::Overflow,
            8 => DeviceHandleError::Pipe,
            9 => DeviceHandleError::Interrupted,
            10 => DeviceHandleError::NoMem,
            11 => DeviceHandleError::NotSupported,
            12 => DeviceHandleError::BadDescriptor,
            13 => DeviceHandleError::Other,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum Direction {
        In,
        Out,
      }
      impl ::core::fmt::Debug for Direction {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            Direction::In => {
              f.debug_tuple("Direction::In").finish()
            }
            Direction::Out => {
              f.debug_tuple("Direction::Out").finish()
            }
          }
        }
      }
      
      impl Direction{
        pub(crate) unsafe fn _lift(val: u8) -> Direction{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => Direction::In,
            1 => Direction::Out,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum UsageType {
        Data,
        Feedback,
        FeedbackData,
        Reserved,
      }
      impl ::core::fmt::Debug for UsageType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            UsageType::Data => {
              f.debug_tuple("UsageType::Data").finish()
            }
            UsageType::Feedback => {
              f.debug_tuple("UsageType::Feedback").finish()
            }
            UsageType::FeedbackData => {
              f.debug_tuple("UsageType::FeedbackData").finish()
            }
            UsageType::Reserved => {
              f.debug_tuple("UsageType::Reserved").finish()
            }
          }
        }
      }
      
      impl UsageType{
        pub(crate) unsafe fn _lift(val: u8) -> UsageType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => UsageType::Data,
            1 => UsageType::Feedback,
            2 => UsageType::FeedbackData,
            3 => UsageType::Reserved,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum SyncType {
        NoSync,
        Asynchronous,
        Adaptive,
        Synchronous,
      }
      impl ::core::fmt::Debug for SyncType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            SyncType::NoSync => {
              f.debug_tuple("SyncType::NoSync").finish()
            }
            SyncType::Asynchronous => {
              f.debug_tuple("SyncType::Asynchronous").finish()
            }
            SyncType::Adaptive => {
              f.debug_tuple("SyncType::Adaptive").finish()
            }
            SyncType::Synchronous => {
              f.debug_tuple("SyncType::Synchronous").finish()
            }
          }
        }
      }
      
      impl SyncType{
        pub(crate) unsafe fn _lift(val: u8) -> SyncType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => SyncType::NoSync,
            1 => SyncType::Asynchronous,
            2 => SyncType::Adaptive,
            3 => SyncType::Synchronous,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, PartialEq)]
      pub enum TransferType {
        Control,
        Isochronous,
        Bulk,
        Interrupt,
      }
      impl ::core::fmt::Debug for TransferType {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            TransferType::Control => {
              f.debug_tuple("TransferType::Control").finish()
            }
            TransferType::Isochronous => {
              f.debug_tuple("TransferType::Isochronous").finish()
            }
            TransferType::Bulk => {
              f.debug_tuple("TransferType::Bulk").finish()
            }
            TransferType::Interrupt => {
              f.debug_tuple("TransferType::Interrupt").finish()
            }
          }
        }
      }
      
      impl TransferType{
        pub(crate) unsafe fn _lift(val: u8) -> TransferType{
          if !cfg!(debug_assertions) {
            return ::core::mem::transmute(val);
          }
          
          match val {
            0 => TransferType::Control,
            1 => TransferType::Isochronous,
            2 => TransferType::Bulk,
            3 => TransferType::Interrupt,
            
            _ => panic!("invalid enum discriminant"),
          }
        }
      }
      
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct Version {
        pub major: u8,
        pub minor: u8,
        pub subminor: u8,
      }
      impl ::core::fmt::Debug for Version {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("Version").field("major", &self.major).field("minor", &self.minor).field("subminor", &self.subminor).finish()
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod descriptors {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type Direction = super::super::super::component::usb::types::Direction;
      pub type SyncType = super::super::super::component::usb::types::SyncType;
      pub type TransferType = super::super::super::component::usb::types::TransferType;
      pub type UsageType = super::super::super::component::usb::types::UsageType;
      pub type Version = super::super::super::component::usb::types::Version;
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct EndpointDescriptor {
        pub address: u8,
        pub direction: Direction,
        pub interval: u8,
        pub max_packet_size: u16,
        pub number: u8,
        pub refresh: u8,
        /// Audio
        pub sync_type: SyncType,
        pub synch_address: u8,
        /// Audio
        pub transfer_type: TransferType,
        pub usage_type: UsageType,
      }
      impl ::core::fmt::Debug for EndpointDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("EndpointDescriptor").field("address", &self.address).field("direction", &self.direction).field("interval", &self.interval).field("max-packet-size", &self.max_packet_size).field("number", &self.number).field("refresh", &self.refresh).field("sync-type", &self.sync_type).field("synch-address", &self.synch_address).field("transfer-type", &self.transfer_type).field("usage-type", &self.usage_type).finish()
        }
      }
      #[derive(Clone)]
      pub struct InterfaceDescriptor {
        pub number: u8,
        pub alternate_setting: u8,
        pub class_code: u8,
        pub subclass_code: u8,
        pub protocol: u8,
        pub interface_string_index: Option<u8>,
        pub endpoint_descriptors: wit_bindgen::rt::vec::Vec::<EndpointDescriptor>,
      }
      impl ::core::fmt::Debug for InterfaceDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("InterfaceDescriptor").field("number", &self.number).field("alternate-setting", &self.alternate_setting).field("class-code", &self.class_code).field("subclass-code", &self.subclass_code).field("protocol", &self.protocol).field("interface-string-index", &self.interface_string_index).field("endpoint-descriptors", &self.endpoint_descriptors).finish()
        }
      }
      #[derive(Clone)]
      pub struct ConfigurationDescriptor {
        pub name: Option<wit_bindgen::rt::string::String>,
        pub max_power: u16,
        pub number: u8,
        pub interfaces: wit_bindgen::rt::vec::Vec::<InterfaceDescriptor>,
      }
      impl ::core::fmt::Debug for ConfigurationDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ConfigurationDescriptor").field("name", &self.name).field("max-power", &self.max_power).field("number", &self.number).field("interfaces", &self.interfaces).finish()
        }
      }
      #[repr(C)]
      #[derive(Clone, Copy)]
      pub struct DeviceDescriptor {
        pub device_class: u8,
        pub device_protocol: u8,
        pub device_subclass: u8,
        pub device_version: Version,
        pub product_id: u16,
        pub usb_version: Version,
        pub vendor_id: u16,
        pub max_packet_size: u8,
        pub manufacturer_string_index: Option<u8>,
        pub product_string_index: Option<u8>,
        pub serial_number_string_index: Option<u8>,
        pub num_configurations: u8,
      }
      impl ::core::fmt::Debug for DeviceDescriptor {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("DeviceDescriptor").field("device-class", &self.device_class).field("device-protocol", &self.device_protocol).field("device-subclass", &self.device_subclass).field("device-version", &self.device_version).field("product-id", &self.product_id).field("usb-version", &self.usb_version).field("vendor-id", &self.vendor_id).field("max-packet-size", &self.max_packet_size).field("manufacturer-string-index", &self.manufacturer_string_index).field("product-string-index", &self.product_string_index).field("serial-number-string-index", &self.serial_number_string_index).field("num-configurations", &self.num_configurations).finish()
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod usb {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type DeviceHandleError = super::super::super::component::usb::types::DeviceHandleError;
      pub type ConfigurationDescriptor = super::super::super::component::usb::descriptors::ConfigurationDescriptor;
      pub type DeviceDescriptor = super::super::super::component::usb::descriptors::DeviceDescriptor;
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct UsbDevice{
        handle: wit_bindgen::rt::Resource<UsbDevice>,
      }
      
      impl UsbDevice{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for UsbDevice{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]usb-device"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      
      #[derive(Debug)]
      #[repr(transparent)]
      pub struct DeviceHandle{
        handle: wit_bindgen::rt::Resource<DeviceHandle>,
      }
      
      impl DeviceHandle{
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
          Self {
            handle: wit_bindgen::rt::Resource::from_handle(handle),
          }
        }
        
        #[doc(hidden)]
        pub fn into_handle(self) -> u32 {
          wit_bindgen::rt::Resource::into_handle(self.handle)
        }
        
        #[doc(hidden)]
        pub fn handle(&self) -> u32 {
          wit_bindgen::rt::Resource::handle(&self.handle)
        }
      }
      
      
      unsafe impl wit_bindgen::rt::WasmResource for DeviceHandle{
        #[inline]
        unsafe fn drop(_handle: u32) {
          #[cfg(not(target_arch = "wasm32"))]
          unreachable!();
          
          #[cfg(target_arch = "wasm32")]
          {
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[resource-drop]device-handle"]
              fn drop(_: u32);
            }
            
            drop(_handle);
          }
        }
      }
      
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        /// Get a list of all configurations of the USB device.
        pub fn configurations(&self,) -> Result<wit_bindgen::rt::vec::Vec::<ConfigurationDescriptor>,DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 12]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]usb-device.configurations"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  let l3 = *((ptr0 + 8) as *const i32);
                  let base33 = l2;
                  let len33 = l3;
                  let mut result33 = Vec::with_capacity(len33 as usize);
                  for i in 0..len33 {
                    let base = base33 + i * 24;
                    let e33 = {
                      let l4 = i32::from(*((base + 0) as *const u8));
                      let l8 = i32::from(*((base + 12) as *const u16));
                      let l9 = i32::from(*((base + 14) as *const u8));
                      let l10 = *((base + 16) as *const i32);
                      let l11 = *((base + 20) as *const i32);
                      let base32 = l10;
                      let len32 = l11;
                      let mut result32 = Vec::with_capacity(len32 as usize);
                      for i in 0..len32 {
                        let base = base32 + i * 16;
                        let e32 = {
                          let l12 = i32::from(*((base + 0) as *const u8));
                          let l13 = i32::from(*((base + 1) as *const u8));
                          let l14 = i32::from(*((base + 2) as *const u8));
                          let l15 = i32::from(*((base + 3) as *const u8));
                          let l16 = i32::from(*((base + 4) as *const u8));
                          let l17 = i32::from(*((base + 5) as *const u8));
                          let l19 = *((base + 8) as *const i32);
                          let l20 = *((base + 12) as *const i32);
                          let base31 = l19;
                          let len31 = l20;
                          let mut result31 = Vec::with_capacity(len31 as usize);
                          for i in 0..len31 {
                            let base = base31 + i * 12;
                            let e31 = {
                              let l21 = i32::from(*((base + 0) as *const u8));
                              let l22 = i32::from(*((base + 1) as *const u8));
                              let l23 = i32::from(*((base + 2) as *const u8));
                              let l24 = i32::from(*((base + 4) as *const u16));
                              let l25 = i32::from(*((base + 6) as *const u8));
                              let l26 = i32::from(*((base + 7) as *const u8));
                              let l27 = i32::from(*((base + 8) as *const u8));
                              let l28 = i32::from(*((base + 9) as *const u8));
                              let l29 = i32::from(*((base + 10) as *const u8));
                              let l30 = i32::from(*((base + 11) as *const u8));
                              
                              super::super::super::component::usb::descriptors::EndpointDescriptor{
                                address: l21 as u8,
                                direction: super::super::super::component::usb::types::Direction::_lift(l22 as u8),
                                interval: l23 as u8,
                                max_packet_size: l24 as u16,
                                number: l25 as u8,
                                refresh: l26 as u8,
                                sync_type: super::super::super::component::usb::types::SyncType::_lift(l27 as u8),
                                synch_address: l28 as u8,
                                transfer_type: super::super::super::component::usb::types::TransferType::_lift(l29 as u8),
                                usage_type: super::super::super::component::usb::types::UsageType::_lift(l30 as u8),
                              }
                            };
                            result31.push(e31);
                          }
                          wit_bindgen::rt::dealloc(base31, (len31 as usize) * 12, 2);
                          
                          super::super::super::component::usb::descriptors::InterfaceDescriptor{
                            number: l12 as u8,
                            alternate_setting: l13 as u8,
                            class_code: l14 as u8,
                            subclass_code: l15 as u8,
                            protocol: l16 as u8,
                            interface_string_index: match l17 {
                              0 => None,
                              1 => {
                                let e = {
                                  let l18 = i32::from(*((base + 6) as *const u8));
                                  
                                  l18 as u8
                                };
                                Some(e)
                              }
                              _ => wit_bindgen::rt::invalid_enum_discriminant(),
                            },
                            endpoint_descriptors: result31,
                          }
                        };
                        result32.push(e32);
                      }
                      wit_bindgen::rt::dealloc(base32, (len32 as usize) * 16, 4);
                      
                      super::super::super::component::usb::descriptors::ConfigurationDescriptor{
                        name: match l4 {
                          0 => None,
                          1 => {
                            let e = {
                              let l5 = *((base + 4) as *const i32);
                              let l6 = *((base + 8) as *const i32);
                              let len7 = l6 as usize;
                              let bytes7 = Vec::from_raw_parts(l5 as *mut _, len7, len7);
                              
                              wit_bindgen::rt::string_lift(bytes7)
                            };
                            Some(e)
                          }
                          _ => wit_bindgen::rt::invalid_enum_discriminant(),
                        },
                        max_power: l8 as u16,
                        number: l9 as u8,
                        interfaces: result32,
                      }
                    };
                    result33.push(e33);
                  }
                  wit_bindgen::rt::dealloc(base33, (len33 as usize) * 24, 4);
                  
                  result33
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l34 = i32::from(*((ptr0 + 4) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l34 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        pub fn device_descriptor(&self,) -> DeviceDescriptor{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(2))]
            struct RetArea([u8; 22]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]usb-device.device-descriptor"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            let l2 = i32::from(*((ptr0 + 1) as *const u8));
            let l3 = i32::from(*((ptr0 + 2) as *const u8));
            let l4 = i32::from(*((ptr0 + 3) as *const u8));
            let l5 = i32::from(*((ptr0 + 4) as *const u8));
            let l6 = i32::from(*((ptr0 + 5) as *const u8));
            let l7 = i32::from(*((ptr0 + 6) as *const u16));
            let l8 = i32::from(*((ptr0 + 8) as *const u8));
            let l9 = i32::from(*((ptr0 + 9) as *const u8));
            let l10 = i32::from(*((ptr0 + 10) as *const u8));
            let l11 = i32::from(*((ptr0 + 12) as *const u16));
            let l12 = i32::from(*((ptr0 + 14) as *const u8));
            let l13 = i32::from(*((ptr0 + 15) as *const u8));
            let l15 = i32::from(*((ptr0 + 17) as *const u8));
            let l17 = i32::from(*((ptr0 + 19) as *const u8));
            let l19 = i32::from(*((ptr0 + 21) as *const u8));
            super::super::super::component::usb::descriptors::DeviceDescriptor{
              device_class: l1 as u8,
              device_protocol: l2 as u8,
              device_subclass: l3 as u8,
              device_version: super::super::super::component::usb::types::Version{
                major: l4 as u8,
                minor: l5 as u8,
                subminor: l6 as u8,
              },
              product_id: l7 as u16,
              usb_version: super::super::super::component::usb::types::Version{
                major: l8 as u8,
                minor: l9 as u8,
                subminor: l10 as u8,
              },
              vendor_id: l11 as u16,
              max_packet_size: l12 as u8,
              manufacturer_string_index: match l13 {
                0 => None,
                1 => {
                  let e = {
                    let l14 = i32::from(*((ptr0 + 16) as *const u8));
                    
                    l14 as u8
                  };
                  Some(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              },
              product_string_index: match l15 {
                0 => None,
                1 => {
                  let e = {
                    let l16 = i32::from(*((ptr0 + 18) as *const u8));
                    
                    l16 as u8
                  };
                  Some(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              },
              serial_number_string_index: match l17 {
                0 => None,
                1 => {
                  let e = {
                    let l18 = i32::from(*((ptr0 + 20) as *const u8));
                    
                    l18 as u8
                  };
                  Some(e)
                }
                _ => wit_bindgen::rt::invalid_enum_discriminant(),
              },
              num_configurations: l19 as u8,
            }
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        /// Open the device. If successfull, this will return a device handle which can be used to interact with the device.
        pub fn open(&self,) -> Result<DeviceHandle,DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]usb-device.open"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 4) as *const i32);
                  
                  DeviceHandle::from_handle(l2 as u32)
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr0 + 4) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl UsbDevice {
        #[allow(unused_unsafe, clippy::all)]
        /// Get a list of all USB devices the guest is allowed to access.
        pub fn enumerate() -> wit_bindgen::rt::vec::Vec::<UsbDevice>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(4))]
            struct RetArea([u8; 8]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[static]usb-device.enumerate"]
              fn wit_import(_: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ){ unreachable!() }
            wit_import(ptr0);
            let l1 = *((ptr0 + 0) as *const i32);
            let l2 = *((ptr0 + 4) as *const i32);
            let base4 = l1;
            let len4 = l2;
            let mut result4 = Vec::with_capacity(len4 as usize);
            for i in 0..len4 {
              let base = base4 + i * 4;
              let e4 = {
                let l3 = *((base + 0) as *const i32);
                
                UsbDevice::from_handle(l3 as u32)
              };
              result4.push(e4);
            }
            wit_bindgen::rt::dealloc(base4, (len4 as usize) * 4, 4);
            result4
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn reset(&self,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.reset"]
              fn wit_import(_: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, ){ unreachable!() }
            wit_import((self).handle() as i32);
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn active_configuration(&self,) -> Result<u8,DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(1))]
            struct RetArea([u8; 2]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.active-configuration"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = i32::from(*((ptr0 + 1) as *const u8));
                  
                  l2 as u8
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l3 = i32::from(*((ptr0 + 1) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l3 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn select_configuration(&self,configuration: u8,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.select-configuration"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(configuration));
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        /// **Interfaces**
        /// Claim an interface.
        pub fn claim_interface(&self,interface: u8,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.claim-interface"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(interface));
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        /// Release an interface.
        pub fn release_interface(&self,interface: u8,){
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.release-interface"]
              fn wit_import(_: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(interface));
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        /// Select an alternate interface.
        pub fn select_alternate_interface(&self,interface: u8,setting: u8,) -> Result<(),DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(1))]
            struct RetArea([u8; 2]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.select-alternate-interface"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(interface), wit_bindgen::rt::as_i32(setting), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l2 = i32::from(*((ptr0 + 1) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l2 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        /// **Reading & Writing**
        pub fn read_interrupt(&self,endpoint: u8,) -> Result<(u64,wit_bindgen::rt::vec::Vec::<u8>,),DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 24]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.read-interrupt"]
              fn wit_import(_: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(endpoint), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  let l3 = *((ptr0 + 16) as *const i32);
                  let l4 = *((ptr0 + 20) as *const i32);
                  let len5 = l4 as usize;
                  
                  (l2 as u64, Vec::from_raw_parts(l3 as *mut _, len5, len5))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*((ptr0 + 8) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn write_interrupt(&self,endpoint: u8,data: &[u8],) -> Result<u64,DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = data;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.write-interrupt"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(endpoint), ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 8) as *const i64);
                  
                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*((ptr1 + 8) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_bulk(&self,endpoint: u8,max_size: u16,) -> Result<(u64,wit_bindgen::rt::vec::Vec::<u8>,),DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 24]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.read-bulk"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(endpoint), wit_bindgen::rt::as_i32(max_size), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  let l3 = *((ptr0 + 16) as *const i32);
                  let l4 = *((ptr0 + 20) as *const i32);
                  let len5 = l4 as usize;
                  
                  (l2 as u64, Vec::from_raw_parts(l3 as *mut _, len5, len5))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*((ptr0 + 8) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn write_bulk(&self,endpoint: u8,data: &[u8],) -> Result<u64,DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = data;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.write-bulk"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(endpoint), ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 8) as *const i64);
                  
                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*((ptr1 + 8) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_isochronous(&self,endpoint: u8,) -> Result<(u64,wit_bindgen::rt::vec::Vec::<u8>,),DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 24]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.read-isochronous"]
              fn wit_import(_: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(endpoint), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  let l3 = *((ptr0 + 16) as *const i32);
                  let l4 = *((ptr0 + 20) as *const i32);
                  let len5 = l4 as usize;
                  
                  (l2 as u64, Vec::from_raw_parts(l3 as *mut _, len5, len5))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*((ptr0 + 8) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn write_isochronous(&self,endpoint: u8,data: &[u8],) -> Result<u64,DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = data;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.write-isochronous"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(endpoint), ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 8) as *const i64);
                  
                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*((ptr1 + 8) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn read_control(&self,request_type: u8,request: u8,value: u16,index: u16,max_size: u16,) -> Result<(u64,wit_bindgen::rt::vec::Vec::<u8>,),DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 24]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let ptr0 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.read-control"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(request_type), wit_bindgen::rt::as_i32(request), wit_bindgen::rt::as_i32(value), wit_bindgen::rt::as_i32(index), wit_bindgen::rt::as_i32(max_size), ptr0);
            let l1 = i32::from(*((ptr0 + 0) as *const u8));
            match l1 {
              0 => {
                let e = {
                  let l2 = *((ptr0 + 8) as *const i64);
                  let l3 = *((ptr0 + 16) as *const i32);
                  let l4 = *((ptr0 + 20) as *const i32);
                  let len5 = l4 as usize;
                  
                  (l2 as u64, Vec::from_raw_parts(l3 as *mut _, len5, len5))
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l6 = i32::from(*((ptr0 + 8) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l6 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      impl DeviceHandle {
        #[allow(unused_unsafe, clippy::all)]
        pub fn write_control(&self,request_type: u8,request: u8,value: u16,index: u16,buf: &[u8],) -> Result<u64,DeviceHandleError>{
          
          #[allow(unused_imports)]
          use wit_bindgen::rt::{alloc, vec::Vec, string::String};
          unsafe {
            
            #[repr(align(8))]
            struct RetArea([u8; 16]);
            let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
            let vec0 = buf;
            let ptr0 = vec0.as_ptr() as i32;
            let len0 = vec0.len() as i32;
            let ptr1 = ret_area.as_mut_ptr() as i32;
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "component:usb/usb@0.2.0")]
            extern "C" {
              #[link_name = "[method]device-handle.write-control"]
              fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, );
            }
            
            #[cfg(not(target_arch = "wasm32"))]
            fn wit_import(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, ){ unreachable!() }
            wit_import((self).handle() as i32, wit_bindgen::rt::as_i32(request_type), wit_bindgen::rt::as_i32(request), wit_bindgen::rt::as_i32(value), wit_bindgen::rt::as_i32(index), ptr0, len0, ptr1);
            let l2 = i32::from(*((ptr1 + 0) as *const u8));
            match l2 {
              0 => {
                let e = {
                  let l3 = *((ptr1 + 8) as *const i64);
                  
                  l3 as u64
                };
                Ok(e)
              }
              1 => {
                let e = {
                  let l4 = i32::from(*((ptr1 + 8) as *const u8));
                  
                  super::super::super::component::usb::types::DeviceHandleError::_lift(l4 as u8)
                };
                Err(e)
              }
              _ => wit_bindgen::rt::invalid_enum_discriminant(),
            }
          }
        }
      }
      
    }
    
    
    #[allow(clippy::all)]
    pub mod events {
      #[used]
      #[doc(hidden)]
      #[cfg(target_arch = "wasm32")]
      static __FORCE_SECTION_REF: fn() = super::super::super::__link_section;
      pub type UsbDevice = super::super::super::component::usb::usb::UsbDevice;
      pub enum DeviceConnectionEvent{
        Pending,
        Closed,
        Connected(UsbDevice),
        Disconnected(UsbDevice),
      }
      impl ::core::fmt::Debug for DeviceConnectionEvent {
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          match self {
            DeviceConnectionEvent::Pending => {
              f.debug_tuple("DeviceConnectionEvent::Pending").finish()
            }
            DeviceConnectionEvent::Closed => {
              f.debug_tuple("DeviceConnectionEvent::Closed").finish()
            }
            DeviceConnectionEvent::Connected(e) => {
              f.debug_tuple("DeviceConnectionEvent::Connected").field(e).finish()
            }
            DeviceConnectionEvent::Disconnected(e) => {
              f.debug_tuple("DeviceConnectionEvent::Disconnected").field(e).finish()
            }
          }
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      pub fn update() -> DeviceConnectionEvent{
        
        #[allow(unused_imports)]
        use wit_bindgen::rt::{alloc, vec::Vec, string::String};
        unsafe {
          
          #[repr(align(4))]
          struct RetArea([u8; 8]);
          let mut ret_area = ::core::mem::MaybeUninit::<RetArea>::uninit();
          let ptr0 = ret_area.as_mut_ptr() as i32;
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "component:usb/events@0.2.0")]
          extern "C" {
            #[link_name = "update"]
            fn wit_import(_: i32, );
          }
          
          #[cfg(not(target_arch = "wasm32"))]
          fn wit_import(_: i32, ){ unreachable!() }
          wit_import(ptr0);
          let l1 = i32::from(*((ptr0 + 0) as *const u8));
          let v4 = match l1 {
            0 => {
              DeviceConnectionEvent::Pending
            }
            1 => {
              DeviceConnectionEvent::Closed
            }
            2 => {
              let e4 = {
                let l2 = *((ptr0 + 4) as *const i32);
                
                super::super::super::component::usb::usb::UsbDevice::from_handle(l2 as u32)
              };
              DeviceConnectionEvent::Connected(e4)
            }
            n => {
              debug_assert_eq!(n, 3, "invalid enum discriminant");
              let e4 = {
                let l3 = *((ptr0 + 4) as *const i32);
                
                super::super::super::component::usb::usb::UsbDevice::from_handle(l3 as u32)
              };
              DeviceConnectionEvent::Disconnected(e4)
            }
          };
          v4
        }
      }
      
    }
    
  }
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:root"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 2954] = [0, 97, 115, 109, 13, 0, 1, 0, 0, 25, 22, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 101, 110, 99, 111, 100, 105, 110, 103, 4, 0, 7, 144, 22, 1, 65, 2, 1, 65, 20, 1, 66, 12, 1, 109, 14, 2, 105, 111, 13, 105, 110, 118, 97, 108, 105, 100, 45, 112, 97, 114, 97, 109, 6, 97, 99, 99, 101, 115, 115, 9, 110, 111, 45, 100, 101, 118, 105, 99, 101, 9, 110, 111, 116, 45, 102, 111, 117, 110, 100, 4, 98, 117, 115, 121, 7, 116, 105, 109, 101, 111, 117, 116, 8, 111, 118, 101, 114, 102, 108, 111, 119, 4, 112, 105, 112, 101, 11, 105, 110, 116, 101, 114, 114, 117, 112, 116, 101, 100, 6, 110, 111, 45, 109, 101, 109, 13, 110, 111, 116, 45, 115, 117, 112, 112, 111, 114, 116, 101, 100, 14, 98, 97, 100, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 5, 111, 116, 104, 101, 114, 4, 0, 19, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 45, 101, 114, 114, 111, 114, 3, 0, 0, 1, 109, 2, 2, 105, 110, 3, 111, 117, 116, 4, 0, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 2, 1, 109, 4, 4, 100, 97, 116, 97, 8, 102, 101, 101, 100, 98, 97, 99, 107, 13, 102, 101, 101, 100, 98, 97, 99, 107, 45, 100, 97, 116, 97, 8, 114, 101, 115, 101, 114, 118, 101, 100, 4, 0, 10, 117, 115, 97, 103, 101, 45, 116, 121, 112, 101, 3, 0, 4, 1, 109, 4, 7, 110, 111, 45, 115, 121, 110, 99, 12, 97, 115, 121, 110, 99, 104, 114, 111, 110, 111, 117, 115, 8, 97, 100, 97, 112, 116, 105, 118, 101, 11, 115, 121, 110, 99, 104, 114, 111, 110, 111, 117, 115, 4, 0, 9, 115, 121, 110, 99, 45, 116, 121, 112, 101, 3, 0, 6, 1, 109, 4, 7, 99, 111, 110, 116, 114, 111, 108, 11, 105, 115, 111, 99, 104, 114, 111, 110, 111, 117, 115, 4, 98, 117, 108, 107, 9, 105, 110, 116, 101, 114, 114, 117, 112, 116, 4, 0, 13, 116, 114, 97, 110, 115, 102, 101, 114, 45, 116, 121, 112, 101, 3, 0, 8, 1, 114, 3, 5, 109, 97, 106, 111, 114, 125, 5, 109, 105, 110, 111, 114, 125, 8, 115, 117, 98, 109, 105, 110, 111, 114, 125, 4, 0, 7, 118, 101, 114, 115, 105, 111, 110, 3, 0, 10, 3, 1, 25, 99, 111, 109, 112, 111, 110, 101, 110, 116, 58, 117, 115, 98, 47, 116, 121, 112, 101, 115, 64, 48, 46, 50, 46, 48, 5, 0, 2, 3, 0, 0, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 2, 3, 0, 0, 9, 115, 121, 110, 99, 45, 116, 121, 112, 101, 2, 3, 0, 0, 13, 116, 114, 97, 110, 115, 102, 101, 114, 45, 116, 121, 112, 101, 2, 3, 0, 0, 10, 117, 115, 97, 103, 101, 45, 116, 121, 112, 101, 2, 3, 0, 0, 7, 118, 101, 114, 115, 105, 111, 110, 1, 66, 22, 2, 3, 2, 1, 1, 4, 0, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 3, 0, 0, 2, 3, 2, 1, 2, 4, 0, 9, 115, 121, 110, 99, 45, 116, 121, 112, 101, 3, 0, 2, 2, 3, 2, 1, 3, 4, 0, 13, 116, 114, 97, 110, 115, 102, 101, 114, 45, 116, 121, 112, 101, 3, 0, 4, 2, 3, 2, 1, 4, 4, 0, 10, 117, 115, 97, 103, 101, 45, 116, 121, 112, 101, 3, 0, 6, 2, 3, 2, 1, 5, 4, 0, 7, 118, 101, 114, 115, 105, 111, 110, 3, 0, 8, 1, 114, 10, 7, 97, 100, 100, 114, 101, 115, 115, 125, 9, 100, 105, 114, 101, 99, 116, 105, 111, 110, 1, 8, 105, 110, 116, 101, 114, 118, 97, 108, 125, 15, 109, 97, 120, 45, 112, 97, 99, 107, 101, 116, 45, 115, 105, 122, 101, 123, 6, 110, 117, 109, 98, 101, 114, 125, 7, 114, 101, 102, 114, 101, 115, 104, 125, 9, 115, 121, 110, 99, 45, 116, 121, 112, 101, 3, 13, 115, 121, 110, 99, 104, 45, 97, 100, 100, 114, 101, 115, 115, 125, 13, 116, 114, 97, 110, 115, 102, 101, 114, 45, 116, 121, 112, 101, 5, 10, 117, 115, 97, 103, 101, 45, 116, 121, 112, 101, 7, 4, 0, 19, 101, 110, 100, 112, 111, 105, 110, 116, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 10, 1, 107, 125, 1, 112, 11, 1, 114, 7, 6, 110, 117, 109, 98, 101, 114, 125, 17, 97, 108, 116, 101, 114, 110, 97, 116, 101, 45, 115, 101, 116, 116, 105, 110, 103, 125, 10, 99, 108, 97, 115, 115, 45, 99, 111, 100, 101, 125, 13, 115, 117, 98, 99, 108, 97, 115, 115, 45, 99, 111, 100, 101, 125, 8, 112, 114, 111, 116, 111, 99, 111, 108, 125, 22, 105, 110, 116, 101, 114, 102, 97, 99, 101, 45, 115, 116, 114, 105, 110, 103, 45, 105, 110, 100, 101, 120, 12, 20, 101, 110, 100, 112, 111, 105, 110, 116, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 115, 13, 4, 0, 20, 105, 110, 116, 101, 114, 102, 97, 99, 101, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 14, 1, 107, 115, 1, 112, 15, 1, 114, 4, 4, 110, 97, 109, 101, 16, 9, 109, 97, 120, 45, 112, 111, 119, 101, 114, 123, 6, 110, 117, 109, 98, 101, 114, 125, 10, 105, 110, 116, 101, 114, 102, 97, 99, 101, 115, 17, 4, 0, 24, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 18, 1, 114, 12, 12, 100, 101, 118, 105, 99, 101, 45, 99, 108, 97, 115, 115, 125, 15, 100, 101, 118, 105, 99, 101, 45, 112, 114, 111, 116, 111, 99, 111, 108, 125, 15, 100, 101, 118, 105, 99, 101, 45, 115, 117, 98, 99, 108, 97, 115, 115, 125, 14, 100, 101, 118, 105, 99, 101, 45, 118, 101, 114, 115, 105, 111, 110, 9, 10, 112, 114, 111, 100, 117, 99, 116, 45, 105, 100, 123, 11, 117, 115, 98, 45, 118, 101, 114, 115, 105, 111, 110, 9, 9, 118, 101, 110, 100, 111, 114, 45, 105, 100, 123, 15, 109, 97, 120, 45, 112, 97, 99, 107, 101, 116, 45, 115, 105, 122, 101, 125, 25, 109, 97, 110, 117, 102, 97, 99, 116, 117, 114, 101, 114, 45, 115, 116, 114, 105, 110, 103, 45, 105, 110, 100, 101, 120, 12, 20, 112, 114, 111, 100, 117, 99, 116, 45, 115, 116, 114, 105, 110, 103, 45, 105, 110, 100, 101, 120, 12, 26, 115, 101, 114, 105, 97, 108, 45, 110, 117, 109, 98, 101, 114, 45, 115, 116, 114, 105, 110, 103, 45, 105, 110, 100, 101, 120, 12, 18, 110, 117, 109, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 115, 125, 4, 0, 17, 100, 101, 118, 105, 99, 101, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 20, 3, 1, 31, 99, 111, 109, 112, 111, 110, 101, 110, 116, 58, 117, 115, 98, 47, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 115, 64, 48, 46, 50, 46, 48, 5, 6, 2, 3, 0, 0, 19, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 45, 101, 114, 114, 111, 114, 2, 3, 0, 1, 24, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 2, 3, 0, 1, 17, 100, 101, 118, 105, 99, 101, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 1, 66, 54, 2, 3, 2, 1, 7, 4, 0, 19, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 45, 101, 114, 114, 111, 114, 3, 0, 0, 2, 3, 2, 1, 8, 4, 0, 24, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 2, 2, 3, 2, 1, 9, 4, 0, 17, 100, 101, 118, 105, 99, 101, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 3, 0, 4, 4, 0, 10, 117, 115, 98, 45, 100, 101, 118, 105, 99, 101, 3, 1, 4, 0, 13, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 3, 1, 1, 104, 6, 1, 112, 3, 1, 106, 1, 9, 1, 1, 1, 64, 1, 4, 115, 101, 108, 102, 8, 0, 10, 4, 0, 33, 91, 109, 101, 116, 104, 111, 100, 93, 117, 115, 98, 45, 100, 101, 118, 105, 99, 101, 46, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 115, 1, 11, 1, 64, 1, 4, 115, 101, 108, 102, 8, 0, 5, 4, 0, 36, 91, 109, 101, 116, 104, 111, 100, 93, 117, 115, 98, 45, 100, 101, 118, 105, 99, 101, 46, 100, 101, 118, 105, 99, 101, 45, 100, 101, 115, 99, 114, 105, 112, 116, 111, 114, 1, 12, 1, 105, 7, 1, 106, 1, 13, 1, 1, 1, 64, 1, 4, 115, 101, 108, 102, 8, 0, 14, 4, 0, 23, 91, 109, 101, 116, 104, 111, 100, 93, 117, 115, 98, 45, 100, 101, 118, 105, 99, 101, 46, 111, 112, 101, 110, 1, 15, 1, 105, 6, 1, 112, 16, 1, 64, 0, 0, 17, 4, 0, 28, 91, 115, 116, 97, 116, 105, 99, 93, 117, 115, 98, 45, 100, 101, 118, 105, 99, 101, 46, 101, 110, 117, 109, 101, 114, 97, 116, 101, 1, 18, 1, 104, 7, 1, 64, 1, 4, 115, 101, 108, 102, 19, 1, 0, 4, 0, 27, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 114, 101, 115, 101, 116, 1, 20, 1, 106, 1, 125, 1, 1, 1, 64, 1, 4, 115, 101, 108, 102, 19, 0, 21, 4, 0, 42, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 97, 99, 116, 105, 118, 101, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 1, 22, 1, 64, 2, 4, 115, 101, 108, 102, 19, 13, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 125, 1, 0, 4, 0, 42, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 115, 101, 108, 101, 99, 116, 45, 99, 111, 110, 102, 105, 103, 117, 114, 97, 116, 105, 111, 110, 1, 23, 1, 64, 2, 4, 115, 101, 108, 102, 19, 9, 105, 110, 116, 101, 114, 102, 97, 99, 101, 125, 1, 0, 4, 0, 37, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 99, 108, 97, 105, 109, 45, 105, 110, 116, 101, 114, 102, 97, 99, 101, 1, 24, 4, 0, 39, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 114, 101, 108, 101, 97, 115, 101, 45, 105, 110, 116, 101, 114, 102, 97, 99, 101, 1, 24, 1, 106, 0, 1, 1, 1, 64, 3, 4, 115, 101, 108, 102, 19, 9, 105, 110, 116, 101, 114, 102, 97, 99, 101, 125, 7, 115, 101, 116, 116, 105, 110, 103, 125, 0, 25, 4, 0, 48, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 115, 101, 108, 101, 99, 116, 45, 97, 108, 116, 101, 114, 110, 97, 116, 101, 45, 105, 110, 116, 101, 114, 102, 97, 99, 101, 1, 26, 1, 112, 125, 1, 111, 2, 119, 27, 1, 106, 1, 28, 1, 1, 1, 64, 2, 4, 115, 101, 108, 102, 19, 8, 101, 110, 100, 112, 111, 105, 110, 116, 125, 0, 29, 4, 0, 36, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 114, 101, 97, 100, 45, 105, 110, 116, 101, 114, 114, 117, 112, 116, 1, 30, 1, 106, 1, 119, 1, 1, 1, 64, 3, 4, 115, 101, 108, 102, 19, 8, 101, 110, 100, 112, 111, 105, 110, 116, 125, 4, 100, 97, 116, 97, 27, 0, 31, 4, 0, 37, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 119, 114, 105, 116, 101, 45, 105, 110, 116, 101, 114, 114, 117, 112, 116, 1, 32, 1, 64, 3, 4, 115, 101, 108, 102, 19, 8, 101, 110, 100, 112, 111, 105, 110, 116, 125, 8, 109, 97, 120, 45, 115, 105, 122, 101, 123, 0, 29, 4, 0, 31, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 114, 101, 97, 100, 45, 98, 117, 108, 107, 1, 33, 4, 0, 32, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 119, 114, 105, 116, 101, 45, 98, 117, 108, 107, 1, 32, 4, 0, 38, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 114, 101, 97, 100, 45, 105, 115, 111, 99, 104, 114, 111, 110, 111, 117, 115, 1, 30, 4, 0, 39, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 119, 114, 105, 116, 101, 45, 105, 115, 111, 99, 104, 114, 111, 110, 111, 117, 115, 1, 32, 1, 64, 6, 4, 115, 101, 108, 102, 19, 12, 114, 101, 113, 117, 101, 115, 116, 45, 116, 121, 112, 101, 125, 7, 114, 101, 113, 117, 101, 115, 116, 125, 5, 118, 97, 108, 117, 101, 123, 5, 105, 110, 100, 101, 120, 123, 8, 109, 97, 120, 45, 115, 105, 122, 101, 123, 0, 29, 4, 0, 34, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 114, 101, 97, 100, 45, 99, 111, 110, 116, 114, 111, 108, 1, 34, 1, 64, 6, 4, 115, 101, 108, 102, 19, 12, 114, 101, 113, 117, 101, 115, 116, 45, 116, 121, 112, 101, 125, 7, 114, 101, 113, 117, 101, 115, 116, 125, 5, 118, 97, 108, 117, 101, 123, 5, 105, 110, 100, 101, 120, 123, 3, 98, 117, 102, 27, 0, 31, 4, 0, 35, 91, 109, 101, 116, 104, 111, 100, 93, 100, 101, 118, 105, 99, 101, 45, 104, 97, 110, 100, 108, 101, 46, 119, 114, 105, 116, 101, 45, 99, 111, 110, 116, 114, 111, 108, 1, 35, 3, 1, 23, 99, 111, 109, 112, 111, 110, 101, 110, 116, 58, 117, 115, 98, 47, 117, 115, 98, 64, 48, 46, 50, 46, 48, 5, 10, 2, 3, 0, 2, 10, 117, 115, 98, 45, 100, 101, 118, 105, 99, 101, 1, 66, 7, 2, 3, 2, 1, 11, 4, 0, 10, 117, 115, 98, 45, 100, 101, 118, 105, 99, 101, 3, 0, 0, 1, 105, 1, 1, 113, 4, 7, 112, 101, 110, 100, 105, 110, 103, 0, 0, 6, 99, 108, 111, 115, 101, 100, 0, 0, 9, 99, 111, 110, 110, 101, 99, 116, 101, 100, 1, 2, 0, 12, 100, 105, 115, 99, 111, 110, 110, 101, 99, 116, 101, 100, 1, 2, 0, 4, 0, 23, 100, 101, 118, 105, 99, 101, 45, 99, 111, 110, 110, 101, 99, 116, 105, 111, 110, 45, 101, 118, 101, 110, 116, 3, 0, 3, 1, 64, 0, 0, 4, 4, 0, 6, 117, 112, 100, 97, 116, 101, 1, 5, 3, 1, 26, 99, 111, 109, 112, 111, 110, 101, 110, 116, 58, 117, 115, 98, 47, 101, 118, 101, 110, 116, 115, 64, 48, 46, 50, 46, 48, 5, 12, 1, 106, 0, 1, 115, 1, 64, 0, 0, 13, 4, 0, 3, 114, 117, 110, 1, 14, 4, 1, 40, 99, 111, 109, 112, 111, 110, 101, 110, 116, 58, 117, 115, 98, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 119, 97, 115, 105, 45, 115, 116, 97, 100, 105, 97, 47, 114, 111, 111, 116, 4, 0, 11, 10, 1, 0, 4, 114, 111, 111, 116, 3, 0, 0, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 50, 49, 46, 48, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 6, 48, 46, 49, 56, 46, 48];

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_section() {}
