package component:usb@0.1.0;

interface types {

    enum device-handle-error {
        io,
        invalid-param,
        access,
        no-device,
        not-found,
        busy,
        timeout,
        overflow,
        pipe,
        interrupted,
        no-mem,
        not-supported,
        bad-descriptor,
        other
    }

    record device-filter {
        vendor-id: option<u16>,
        product-id: option<u16>,
        class-code: option<u8>,
        subclass-code: option<u8>,
        protocol-code: option<u8>,
        serial-number: option<string>
    }

    enum direction { in, out }

    enum usage-type { data, feedback, feedback-data, reserved }

    enum sync-type { no-sync, asynchronous, adaptive, synchronous }

    enum transfer-type { control, isochronous, bulk, interrupt }

    record endpoint-descriptor {
        address: u8,
        direction: direction,
        interval: u8,
        max-packet-size: u16,
        number: u8,
        refresh: u8, // Audio
        sync-type: sync-type,
        synch-address: u8, // Audio
        transfer-type: transfer-type,
        usage-type: usage-type
    }

    record interface-descriptor {
        class-code: u8,
        endpoint-descriptors: list<endpoint-descriptor>
    }

    record %interface {
        number: u8,
        descriptors: list<interface-descriptor>
    }

    record configuration {
        name: option<string>,
        max-power: u16,
        number: u8,
        interfaces: list<%interface>
    }

    record version {
        major: u8,
        minor: u8,
        subminor: u8
    }

    record properties {
        device-class: u8,
        device-protocol: u8,
        device-subclass: u8,
        device-version: version,
        product-id: u16,
        usb-version: version,
        vendor-id: u16
    }
}

interface device {
    use types.{properties, configuration, device-handle-error, device-filter};

    resource usb-device {
        configuration: func() -> result<configuration, device-handle-error>;
        configurations: func() -> result<list<configuration>, device-handle-error>;

        properties: func() -> properties;

        product-name: func() -> result<string, device-handle-error>;
        manufacturer-name: func() -> result<string, device-handle-error>;
        serial-number: func() -> result<string, device-handle-error>;

        open: func() -> result<device-handle, device-handle-error>;
    }

    resource device-handle {
        select-configuration: func(configuration: u8);
        claim-interface: func(%interface: u8);
        unclaim-interface: func(%interface: u8);
        write-interrupt: func(endpoint: u8, data: list<u8>) -> result<u64, device-handle-error>;
        write-bulk: func(endpoint: u8, data: list<u8>) -> result<u64, device-handle-error>;
        read-bulk: func(endpoint: u8) -> result<tuple<u64, list<u8>>, device-handle-error>;
        read-interrupt: func(endpoint: u8) -> result<tuple<u64, list<u8>>, device-handle-error>;
        select-alternate-interface: func(%interface: u8, setting: u8) -> result<_, device-handle-error>;
        detach-kernel-driver: func(%interface: u8) -> result<_, device-handle-error>;
        kernel-driver-active: func(%interface: u8) -> result<bool, device-handle-error>;
    }

    get-devices: func() -> list<usb-device>;

    request-device: func(filter: device-filter) -> option<usb-device>;
}

interface events {
    use device.{usb-device};

    variant device-connection-event {
        pending,
        closed,
        connected(usb-device),
        disconnected(usb-device)
    }

    update: func() -> device-connection-event;
}

world usb-host {
    import device;
    import types;
    export device;
    export types;
    import events;
    export events;
}

world usb {
    import device;
    import types;
    export events;
}
